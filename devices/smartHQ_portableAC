/*

Copyright 2022 - tomw

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

-------------------------------------------

Change history:

0.9.1 - tomw - Added support for Portable AC

*/

metadata 
{
    definition(name: "SmartHQ Portable AC", namespace: "tomw", author: "tomw") 
    {
        capability "FanControl"
        capability "Refresh"
        capability "RelaySwitch"
        capability "Switch"
        capability "ThermostatOperatingState"
        capability "ThermostatSetpoint"
        
        command "adjustSetpoint", ["number"]
        
        // overriding default options for setSpeed
        command "setSpeed", [[name: "Fan speed*",type:"ENUM", description:"Fan speed to set", constraints: fanModeNames()]]        
        
        attribute "currentTemp", "number"
    }
}

#include tomw.smarthqHelpers

def logDebug(msg) 
{
    log.debug(msg)
}

def fanModeNames()
{
    fanSettings.collect { it.value.toString() }
}

def installed()
{
    def modes = fanModeNames()
    
    sendEvent(name: "supportedFanSpeeds", value: modes)
}

def refresh()
{
    refreshAppliance()
}

def parse(item)
{
    if(!item)
    {
        return
    }
    
    logDebug(item)
    
    def switchVal = item.erd?.toLowerCase()
    switch(switchVal)
    {
        case AC_TARGET_TEMPERATURE:
        case AC_AMBIENT_TEMPERATURE:
            parseTemp(item.value, switchVal)
            break
        
        case AC_FAN_SETTING:
            parseFanSetting(item.value)
            break
        
        case AC_POWER_STATUS:
            parsePowerStatus(item.value)
            break
            
        case AC_OPERATION_MODE:
            parseOperatingMode(item.value)
            break
    }
}

def parsePowerStatus(value)
{
    try
    {
        def bytes = hubitat.helper.HexUtils.hexStringToByteArray(value)
        sendEvent(name: "switch", value: decodeErdInt(bytes[0]) ? "on" : "off")
    }
    catch (Exception e)
    {
        logDebug("parse error: ${e.message}")
    }
}

def parseTemp(value, option)
{
    try
    {
        def bytes = hubitat.helper.HexUtils.hexStringToByteArray(value)
        
        def eventName = ""
        switch(option)
        {
            case AC_AMBIENT_TEMPERATURE:
                eventName = "currentTemp"
                break
            
            case AC_TARGET_TEMPERATURE:
                eventName = "thermostatSetpoint"
                break
        }
        
        sendEvent(name: eventName, value: decodeErdInt(bytes))
    }
    catch (Exception e)
    {
        logDebug("parse error: ${e.message}")
    }
}

def parseOperatingMode(value)
{
    try
    {
        def bytes = hubitat.helper.HexUtils.hexStringToByteArray(value)
        sendEvent(name: "thermostatOperatingState", value: operationModes[decodeErdInt(bytes[0]).toInteger()])
    }
    catch (Exception e)
    {
        logDebug("parse error: ${e.message}")
    }  
}

def parseFanSetting(value)
{
    try
    {
        def bytes = hubitat.helper.HexUtils.hexStringToByteArray(value)
        sendEvent(name: "speed", value: fanSettings[decodeErdInt(bytes[0]).toInteger()])
    }
    catch (Exception e)
    {
        logDebug("parse error: ${e.message}")
    }  
}

def adjustSetpoint(temp)
{
    def value = encodeErdInt(temp.toInteger(), 2)
    def erdMap = buildErdSetter(buildDevDetails(), buildErdDetails(AC_TARGET_TEMPERATURE, value))
    
    parent?.sendWssMap(erdMap)
}

def on()
{
    setPowerStatus(true)    
}

def off()
{
    setPowerStatus(false)    
}

def setPowerStatus(boolean mode)
{
    def value = encodeErdInt(mode ? 1 : 0, 1)
    def erdMap = buildErdSetter(buildDevDetails(), buildErdDetails(AC_POWER_STATUS, value))
    
    parent?.sendWssMap(erdMap)    
}

def setSpeed(fanspeed)
{
    def intSpeed = fanSettings.find {fanspeed == it.value}?.key?.toInteger()
    
    if(!intSpeed)
    {
        // unsupported value sent, so discarding
        log.debug "invalid fanspeed (${fanspeed})"
        return
    }
    
    def value = encodeErdInt(intSpeed, 1)
    def erdMap = buildErdSetter(buildDevDetails(), buildErdDetails(AC_FAN_SETTING, value))
    
    parent?.sendWssMap(erdMap) 
}

def cycleSpeed()
{
    log.debug "cycleSpeed() not supported"
}

import groovy.transform.Field

@Field Map operationModes = 
    [
        0: "cool",
        1: "fan_only",
        2: "energy_saver",
        3: "heat",
        4: "dry",
        5: "auto",
        9: "default"
    ]

@Field Map fanSettings =
    [
        0: "default",
        1: "auto",
        2: "low",
        3: "low_auto",
        4: "medium",
        5: "med_auto",
        8: "high",
        9: "high_auto"
    ]

@Field AC_TARGET_TEMPERATURE = "0x7003"
@Field AC_FAN_SETTING = "0x7a00"
@Field AC_OPERATION_MODE = "0x7a01"
@Field AC_AMBIENT_TEMPERATURE = "0x7a02"
@Field AC_FILTER_STATUS = "0x7a04"
@Field AC_POWER_STATUS = "0x7a0f"
@Field AC_UNKNOWN7A12 = "0x7a12"
